# 第三周
## 2020-11-30
---
本次课重点和难点：环境变量

---
### 1、if和else if的区别
1、if为如果，就是如果这种情况，如果那种情况。  
2、else if 不是上一个条件的前提下，如果zhuan是这个条件。  
3、if无论是否满足shu条件都会向下执行，知道程序结束，else if 满足一个条件就会停止执行。  
4、由于if都会执行一遍，则可能会同一个需要判断的事件，会进入2个if语句中，出现错误，而else if就不会发生这样的事情。
### 2、JDK的下载安装
下载网址：java.sun.com ->> https://www.oracle.com/java/technologies/  

关于该网址的小知识：  
java最早是sun公司发明出来的，然后sun公司在2009年被oracle公司收购，sun就成为了oracle的子公司，所以JDK的域名也更换成了oracle公司的域名，而为了保存sun公司的这段历史，原来的域名也被保留了下来，输入java.sun.com仍能进入，可是会跳转到oracle公司的网站，所以留下原来的域名，相当于就是留下了一段历史  

JDK的一些知识：  
JavaSE：standard（标准）  
JavaEE：Enterprise Edition（企业版）  

JDK的下载：  
在这里，我们下载64位的 Java SE 8u271  
而对于JDK的理解：JDK（开发人员，既要进行源代码的编译也要运行程序），其中包含了JRE   
其中包含的JRE（运行java程序的电脑，必须安装jre（java运行时环境）

所以我们写代码的过程基本可以写成以下的过程：  
1、安装JDK  
2、写程序  
3、对代码进行编译  

而对代码进行编译的过程，就是将我们看得懂的代码，翻译成机器看得懂的语言的一个过程
### 3、环境变量的配置
当我们在cmd中调用各种程序时，往往会因为不同的程序放在不同的文件夹中，导致在使用时需要在前面加上一段长长的路径，显得非常麻烦。  
所以在这里，我们要配置的环境变量就解决了这个问题，我们将程序所在的绝对路径复制下载，在环境变量的path一项中，将其添加进去，就相当于告诉了电脑，我把这个东西的路径告诉你，下次我在控制台使用它的时候，你就来这里找他，就不用每次都写一串长长的路径，大大提高了效率。  

比如这个目录：   
C:\Program Files\Java\jdk1.8.0_271\bin：目录中包含了我们编译程序用的javac.exe和运行程序程序的java.exe  
所以当我们把这个路径添加到环境变量中之后，下次我们使用javac.exe和java.exe时，只需要输入javac以及java就可以了，就不同每次都添加前面的路径。  

### 4、环境变量使用实例（annie的使用）
annie是github上一个十分好用的下载各个网站的电影的程序，由国外的作者开发，并由全球所有github用户来进行维护，直到现在，annie已经涵盖了国内大部分主流视频网站的下载，我们下载annie，并配置好环境变量，就可以在控制台中输入“annie -i +视频网址”，就可以解析网址包含的视频信息，然后在输入“annie -f +清晰度+网址”就可以对电影进行下载，而下载的电影是被分成很多个部分的片段，这时我们就需要一个配套的软件，将这些片段合成一个完整的电影。这就是ffmpeg，同样下载它。放到文件夹中，然后配置环境变量，就可以了，进行电影的下载时，他就会自动对电影进行合成，合成一个完整的电影。
### 5、课后
1、在控制台中输入qq，可以启动qq进行登录
2、使用annie下载电影《桂河大桥》

## 2020-12-04
### 1、环境变量：CLASSPATH
- 解读classpath：  
class:类
path：路径
则classpath即为类的路径
- 什么时候需要配置classpath
当我们编写java程序需要使用第三方类库时，就需要配置classpath环境变量  
- 配置classpath
与上次课中配置环境变量一样，打开属性中的环境变量，但不同的是，这次是在其中创建一个新的classpath的选项，在其中黏贴第三方类类库的文件路径，就可以在编写java文件时使用第三方类库
- 第三方类库
java中拥有非常多的第三方类库，当我们想实现一些java官方无法实现的操作时，就可以使用第三方类库进行实现
如比较知名的有：https://poi.apache.org/
### 2、环境变量：JAVA_HOME
- 什么时候需要配置JAVA_HOME
当我们需要使用第三方的软件时，就需要配置这个环境变量
- 配置JAVA_HOME
在环境变量中创建一个JAVA_HOME的选项，并将JDK的地址复制到其中，就可以了  
当配置环境变量时，环境变量path中的路径就可以换成%JAVA_HOME%\bin，更加简洁
### 3、变量
- 赋值符号
1. 整型

| 类型 | 位数 | 取值范围 |
| :---- | :---- | :---- |
| byte | 8位 | -2^7~2^7 |
| short | 16位 | -2^15~2^15 |
| int | 32位 | -2^31~2^31 |
| long（数字后加上l或L） | 64位 | -2^63~2^63 |

2. 小数（浮点型）

| 类型 | 位数 | 取值范围 |
| :---- | :---- | :---- |
| float（数字后加上f或F） | 32位 | 1.4E-45~3.4E38 |
| double | 64位 | 4.9E-324~1.8E308 |

3. 字符型

| 类型 | 位数 | 取值范围 |
| :---- | :---- | :---- |
| char（可存汉字） | 16位 | 使用Unicode编码（2个字节） |

4. 布尔型

| 类型 | 位数 | 取值范围 |
| :---- | :----: | :---- |
| boolean | - | 只有ture和false两个取值 |

5. 注意：
电脑分配内存的最小单位：字节  
1字节 = 8个位

### 4、课后
#### 《Java语言基础与面向对象编程实践》P19第四题
- 请描述什么是Java的垃圾回收机制？
当没有对象引用指向原先分配给某个对象的内存时，该内存便成为了垃圾。  
而Java虚拟机提供了一个系统级线程（垃圾回收器线程），他自动跟踪每块被分配出去的内存空间，自动释放被定义成垃圾的内存。  
垃圾回收机制可以自动释放回收空间，减轻程序员负担，而在没有垃圾回收机制的时候，就要花很多时间来解决释放无用的内存的问题，所以在编程的时候，靠垃圾回收机制可以缩短时间。  
垃圾回收机制是一个系统级的线程，在带来方便的同时，同时也会影响系统性能，因为他在释放无用内存的时候，需要追踪分配的内存，这个过程则需要花费资源。  
在编程的时候，可以使用System.gc()这个方法来通知Java虚拟机释放无用资源，但是它会选择在合适的时候释放，不是在我们调用System.gc()的时候，而是一个它决定的时间，我们不能控制。  
- Java虚拟机执行垃圾回收的算法：
    1. Mark-Sweep(标记-清除)算法
    最基础的一种算法，分为两个步骤，第一步就是标记，也就是标记处所有需要回收的对象，标记完成后就进行统一的回收掉哪些带有标记的对象。这种算法优点是简单，缺点是效率问题，还有一个最大的缺点是空间问题，标记清除之后会产生大量不连续的内存碎片，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而造成内存空间浪费。
    2. Copying(复制)算法
    复制将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。只是这种算法的代价是将内存缩小为原来的一半。
    3. Mark-Compct(标记-整理)算法
    标记整理算法与标记清除算法很相似，但最显著的区别是：标记清除算法仅对不存活的对象进行处理，剩余存活对象不做任何处理，造成内存碎片；而标记整理算法不仅对不存活对象进行处理清除，还对剩余的存活对象进行整理，重新整理，因此其不会产生内存碎片。
    4. Generational Collection(分代收集)算法
    分代收集算法是一种比较智能的算法，也是现在jvm使用最多的一种算法，他本身其实不是一个新的算法，而是他会在具体的场景自动选择以上三种算法进行垃圾对象回收。